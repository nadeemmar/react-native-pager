{"version":3,"file":"react-native-pager.cjs.production.min.js","sources":["../src/pager.tsx","../src/util.ts","../src/pagination.tsx"],"sourcesContent":["import React, {\r\n  useState,\r\n  Children,\r\n  createContext,\r\n  useContext,\r\n  useEffect,\r\n} from 'react';\r\nimport { StyleSheet, LayoutChangeEvent, ViewStyle } from 'react-native';\r\nimport Animated from 'react-native-reanimated';\r\nimport {\r\n  PanGestureHandler,\r\n  State,\r\n  PanGestureHandlerProperties,\r\n} from 'react-native-gesture-handler';\r\n\r\nexport type SpringConfig = {\r\n  damping: Animated.Adaptable<number>;\r\n  mass: Animated.Adaptable<number>;\r\n  stiffness: Animated.Adaptable<number>;\r\n  overshootClamping: Animated.Adaptable<number> | boolean;\r\n  restSpeedThreshold: Animated.Adaptable<number>;\r\n  restDisplacementThreshold: Animated.Adaptable<number>;\r\n  toValue: Animated.Adaptable<number>;\r\n};\r\n\r\n// copied from react-native-reanimated for now, can't get the export\r\nexport enum Extrapolate {\r\n  EXTEND = 'extend',\r\n  CLAMP = 'clamp',\r\n  IDENTITY = 'identity',\r\n}\r\n\r\ninterface InterpolationConfig {\r\n  inputRange: ReadonlyArray<Animated.Adaptable<number>>;\r\n  outputRange: ReadonlyArray<Animated.Adaptable<number>>;\r\n  extrapolate?: Extrapolate;\r\n  extrapolateLeft?: Extrapolate;\r\n  extrapolateRight?: Extrapolate;\r\n}\r\n\r\ntype iInterpolationFn = (\r\n  offset: Animated.Node<number>\r\n) => Animated.Node<number>;\r\n\r\ninterface iInterpolationConfig extends InterpolationConfig {\r\n  unit?: string;\r\n}\r\n\r\ntype iTransformProp = {\r\n  [transformProp: string]: iInterpolationConfig | iInterpolationFn;\r\n};\r\n\r\nexport interface iPageInterpolation {\r\n  [animatedProp: string]:\r\n    | iTransformProp[]\r\n    | iInterpolationConfig\r\n    | iInterpolationFn;\r\n}\r\n\r\nconst VERTICAL = 1;\r\nconst HORIZONTAL = 2;\r\nconst UNSET = -1;\r\nconst TRUE = 1;\r\nconst FALSE = 0;\r\n\r\nconst {\r\n  event,\r\n  block,\r\n  Value,\r\n  divide,\r\n  cond,\r\n  eq,\r\n  add,\r\n  stopClock,\r\n  Clock,\r\n  set,\r\n  clockRunning,\r\n  multiply,\r\n  sub,\r\n  call,\r\n  max,\r\n  min,\r\n  greaterThan,\r\n  abs,\r\n  ceil,\r\n  interpolate,\r\n  concat,\r\n  neq,\r\n  and,\r\n  startClock,\r\n  spring,\r\n  // @ts-ignore\r\n  debug,\r\n} = Animated;\r\n\r\nexport interface iPager {\r\n  activeIndex?: number;\r\n  onChange?: (nextIndex: number) => void;\r\n  initialIndex?: number;\r\n  children: React.ReactNode[];\r\n  springConfig?: Partial<SpringConfig>;\r\n  pageInterpolation?: iPageInterpolation;\r\n  panProps?: Partial<PanGestureHandlerProperties>;\r\n  pageSize?: number;\r\n  threshold?: number;\r\n  minIndex?: number;\r\n  maxIndex?: number;\r\n  adjacentChildOffset?: number;\r\n  style?: ViewStyle;\r\n  containerStyle?: ViewStyle;\r\n  animatedValue?: Animated.Value<number>;\r\n  animatedIndex?: Animated.Value<number>;\r\n  type?: 'horizontal' | 'vertical';\r\n  clamp?: {\r\n    prev?: number;\r\n    next?: number;\r\n  };\r\n  clampDrag?: {\r\n    prev?: number;\r\n    next?: number;\r\n  };\r\n}\r\nconst REALLY_BIG_NUMBER = 1000000000;\r\n\r\n// at its core, this component converts an activeIndex integer value to an Animated.Value\r\n// this animated value represents all intermediate values of a pager, e.g when a user is dragging, the index\r\n// value might be anything between 1 -> 2 as they are moving. when a gesture is completed, it figures out\r\n// the next activeIndex, snaps to it and passes it back. it also handles snapping to different indices when the activeIndex\r\n// prop changes.\r\n\r\n// all styles and positioning of child screens can be computed from this one value, based on a childs index and\r\n// any style config props passed to the Pager.\r\n\r\n// pretty much all other props passed to the Pager are configurations for different behaviours of what is described above\r\n\r\nfunction Pager({\r\n  activeIndex: parentActiveIndex,\r\n  onChange: parentOnChange,\r\n  initialIndex = 0,\r\n  children,\r\n  springConfig,\r\n  panProps = {},\r\n  pageSize = 1,\r\n  threshold = 0.1,\r\n  minIndex = 0,\r\n  maxIndex: parentMax,\r\n  adjacentChildOffset = 10,\r\n  style,\r\n  containerStyle,\r\n  type = 'horizontal',\r\n  pageInterpolation,\r\n  clamp = {},\r\n  clampDrag = {},\r\n  animatedValue,\r\n}: iPager) {\r\n  const context = useContext(PagerContext);\r\n\r\n  const isControlled = parentActiveIndex !== undefined;\r\n\r\n  const [_activeIndex, _onChange] = useState(initialIndex);\r\n\r\n  const activeIndex = isControlled\r\n    ? (parentActiveIndex as number)\r\n    : context\r\n    ? (context[0] as number)\r\n    : (_activeIndex as number);\r\n\r\n  const numberOfScreens = Children.count(children);\r\n\r\n  const maxIndex =\r\n    parentMax === undefined\r\n      ? Math.ceil((numberOfScreens - 1) / pageSize)\r\n      : parentMax;\r\n\r\n  const onChange = isControlled\r\n    ? (parentOnChange as any)\r\n    : context\r\n    ? (context[1] as any)\r\n    : (_onChange as any);\r\n\r\n  const dragX = memoize(new Value(0));\r\n  const dragY = memoize(new Value(0));\r\n  const gestureState = memoize(new Value(0));\r\n\r\n  const handleGesture = memoize(\r\n    event(\r\n      [\r\n        {\r\n          nativeEvent: {\r\n            translationX: dragX,\r\n            translationY: dragY,\r\n          },\r\n        },\r\n      ],\r\n      { useNativeDriver: true }\r\n    )\r\n  );\r\n\r\n  const handleStateChange = memoize(\r\n    event(\r\n      [\r\n        {\r\n          nativeEvent: {\r\n            state: gestureState,\r\n          },\r\n        },\r\n      ],\r\n      {\r\n        useNativeDriver: true,\r\n      }\r\n    )\r\n  );\r\n\r\n  let initialWidth = UNSET;\r\n  if (style && style.width) {\r\n    if (typeof style.width === 'number') {\r\n      initialWidth = style.width;\r\n    }\r\n  }\r\n\r\n  let initialHeight = UNSET;\r\n  if (style && style.height) {\r\n    if (typeof style.height === 'number') {\r\n      initialHeight = style.height;\r\n    }\r\n  }\r\n\r\n  const [width, setWidth] = useState(initialWidth);\r\n  const [height, setHeight] = useState(initialHeight);\r\n\r\n  // assign references based on vertical / horizontal configurations\r\n  const dimension = memoize(new Value(0));\r\n  const targetDimension = type === 'vertical' ? 'height' : 'width';\r\n  const targetTransform = type === 'vertical' ? 'translateY' : 'translateX';\r\n  const delta = type === 'vertical' ? dragY : dragX;\r\n\r\n  const layoutDimension = type === 'vertical' ? height : width;\r\n\r\n  // `totalDimension` on the container view is required for android layouts to work properly\r\n  // otherwise translations move the panHandler off of the screen\r\n  // set the total width of the container view to the sum width of all the screens\r\n  const totalDimension = multiply(dimension, numberOfScreens);\r\n\r\n  function handleLayout({ nativeEvent: { layout } }: LayoutChangeEvent) {\r\n    layout.width !== width && setWidth(layout.width);\r\n    layout.height !== height && setHeight(layout.height);\r\n  }\r\n\r\n  const TYPE = type === 'vertical' ? VERTICAL : HORIZONTAL;\r\n\r\n  // props that might change over time should be reactive:\r\n  const animatedThreshold = useAnimatedValue(threshold);\r\n  const clampDragPrev = useAnimatedValue(clampDrag.prev, REALLY_BIG_NUMBER);\r\n  const clampDragNext = useAnimatedValue(clampDrag.next, REALLY_BIG_NUMBER);\r\n  const animatedMaxIndex = useAnimatedValue(maxIndex);\r\n  const animatedMinIndex = useAnimatedValue(minIndex);\r\n\r\n  // set the initial position - priority to direct prop over context, and context over uncontrolled\r\n  const _position = memoize(new Value(activeIndex));\r\n  const position = animatedValue\r\n    ? animatedValue\r\n    : context\r\n    ? context[2]\r\n    : _position;\r\n\r\n  // pan event values to track\r\n  const dragStart = memoize(new Value(0));\r\n  const swiping = memoize(new Value(FALSE));\r\n  const nextIndex = memoize(new Value(activeIndex));\r\n  const animatedActiveIndex = memoize(new Value(activeIndex));\r\n  const change = memoize(sub(animatedActiveIndex, position));\r\n  const absChange = memoize(abs(change));\r\n  const shouldTransition = memoize(greaterThan(absChange, animatedThreshold));\r\n  const indexChange = memoize(new Value(0));\r\n\r\n  // clamp drag values between the configured clamp props\r\n  // e.g prev => 0.5, next => 0.5 means change can only be between [-0.5, 0.5]\r\n  // minMax order is reversed because next is negative in translation values\r\n  const clampedDelta = memoize(\r\n    min(\r\n      max(divide(delta, dimension), multiply(clampDragNext, -1)),\r\n      clampDragPrev\r\n    )\r\n  );\r\n\r\n  const clock = memoize(new Clock());\r\n\r\n  // snap focus to activeIndex when it updates\r\n  useEffect(() => {\r\n    if (activeIndex >= minIndex && activeIndex <= maxIndex) {\r\n      nextIndex.setValue(activeIndex);\r\n    }\r\n  }, [activeIndex, minIndex, maxIndex]);\r\n\r\n  // animatedIndex represents pager position with an animated value\r\n  // this value is used to compute the transformations of the container screen\r\n  // its also used to compute the offsets of child screens, and any other consumers\r\n  const animatedIndex = memoize(\r\n    block([\r\n      cond(\r\n        eq(gestureState, State.ACTIVE),\r\n        [\r\n          cond(clockRunning(clock), stopClock(clock)),\r\n          // captures the initial drag value on first drag event\r\n          cond(swiping, 0, [set(dragStart, position), set(swiping, TRUE)]),\r\n\r\n          set(position, sub(dragStart, clampedDelta)),\r\n        ],\r\n        [\r\n          // on release -- figure out if the index needs to change, and what index it should change to\r\n          cond(swiping, [\r\n            set(swiping, FALSE),\r\n            cond(shouldTransition, [\r\n              // rounds index change if pan gesture greater than just one screen\r\n              set(indexChange, ceil(absChange)),\r\n              // nextIndex set to the next snap point\r\n              set(\r\n                nextIndex,\r\n                cond(\r\n                  greaterThan(change, 0),\r\n                  min(\r\n                    max(\r\n                      sub(animatedActiveIndex, indexChange),\r\n                      animatedMinIndex\r\n                    ),\r\n                    animatedMaxIndex\r\n                  ),\r\n                  min(\r\n                    max(\r\n                      add(animatedActiveIndex, indexChange),\r\n                      animatedMinIndex\r\n                    ),\r\n                    animatedMaxIndex\r\n                  )\r\n                )\r\n              ),\r\n              // update w/ value that will be snapped to\r\n              call([nextIndex], ([nextIndex]) => onChange(nextIndex)),\r\n            ]),\r\n          ]),\r\n\r\n          // set animatedActiveIndex for next swipe event\r\n          set(animatedActiveIndex, nextIndex),\r\n          set(position, runSpring(clock, position, nextIndex, springConfig)),\r\n        ]\r\n      ),\r\n      position,\r\n    ])\r\n  );\r\n\r\n  const clampPrevValue = useAnimatedValue(clamp.prev, numberOfScreens);\r\n  const clampNextValue = useAnimatedValue(clamp.next, numberOfScreens);\r\n\r\n  // stop child screens from translating beyond the bounds set by clamp props:\r\n  const minimum = memoize(\r\n    multiply(sub(animatedIndex, clampPrevValue), dimension)\r\n  );\r\n\r\n  const maximum = memoize(\r\n    multiply(add(animatedIndex, clampNextValue), dimension)\r\n  );\r\n\r\n  const animatedPageSize = useAnimatedValue(pageSize);\r\n\r\n  // container offset -- this is the window of focus for active screens\r\n  // it shifts around based on the animatedIndex value\r\n  const containerTranslation = memoize(\r\n    multiply(animatedIndex, dimension, animatedPageSize, -1)\r\n  );\r\n\r\n  // slice the children that are rendered by the <Pager />\r\n  // this enables very large child lists to render efficiently\r\n  // the downside is that children are unmounted after they pass this threshold\r\n  // it's an optional prop, however a default value of ~20 is set here to prevent\r\n  // possible performance bottlenecks to those not aware of the prop or what it does\r\n\r\n  // this will slice adjacentChildOffset number of children previous and after\r\n  // the current active child index into a smaller child array\r\n  const adjacentChildren =\r\n    adjacentChildOffset !== undefined\r\n      ? children.slice(\r\n          Math.max(activeIndex - adjacentChildOffset, 0),\r\n          Math.min(activeIndex + adjacentChildOffset + 1, numberOfScreens)\r\n        )\r\n      : children;\r\n\r\n  // grabbing the height property from the style prop if there is no container style, this reduces\r\n  // the chances of messing up the layout with containerStyle configurations\r\n  // can be overridden by the prop itself, but its likely that this is what is intended most of the time\r\n  // also has the benefit of covering 100% width of container, meaning better pan coverage on android\r\n  const defaultContainerStyle =\r\n    style && style.height ? { height: style.height } : undefined;\r\n\r\n  function renderChildren() {\r\n    // waiting for initial layout - except when testing\r\n    if (width === UNSET) {\r\n      return null;\r\n    }\r\n\r\n    return adjacentChildren.map((child: any, i) => {\r\n      // use map instead of React.Children because we want to track\r\n      // the keys of these children by there index\r\n      // React.Children shifts these key values intelligently, but it\r\n      // causes issues with the memoized values in <Page /> components\r\n      let index = i;\r\n\r\n      if (adjacentChildOffset !== undefined) {\r\n        index =\r\n          activeIndex <= adjacentChildOffset\r\n            ? i\r\n            : activeIndex - adjacentChildOffset + i;\r\n      }\r\n\r\n      return (\r\n        <IndexProvider index={index} key={index}>\r\n          <FocusProvider focused={index === activeIndex}>\r\n            <Page\r\n              index={index}\r\n              animatedIndex={animatedIndex}\r\n              minimum={minimum}\r\n              maximum={maximum}\r\n              dimension={dimension}\r\n              targetTransform={targetTransform}\r\n              targetDimension={targetDimension}\r\n              pageInterpolation={pageInterpolation}\r\n            >\r\n              {child}\r\n            </Page>\r\n          </FocusProvider>\r\n        </IndexProvider>\r\n      );\r\n    });\r\n  }\r\n\r\n  // extra Animated.Views below may seem redundant but they preserve applied styles e.g padding and margin\r\n  // of the page views\r\n  return (\r\n    <Animated.View\r\n      style={containerStyle || defaultContainerStyle || { flex: 1 }}\r\n    >\r\n      <Animated.Code\r\n        key={layoutDimension}\r\n        exec={cond(\r\n          // dimension already set to last layout\r\n          and(eq(dimension, width), eq(dimension, height)),\r\n          [],\r\n          [\r\n            cond(\r\n              eq(TYPE, VERTICAL),\r\n              set(dimension, height),\r\n              set(dimension, width)\r\n            ),\r\n          ]\r\n        )}\r\n      />\r\n\r\n      <PanGestureHandler\r\n        {...panProps}\r\n        onGestureEvent={handleGesture}\r\n        onHandlerStateChange={handleStateChange}\r\n      >\r\n        <Animated.View style={{ flex: 1 }}>\r\n          <Animated.View style={style || { flex: 1 }}>\r\n            <Animated.View style={{ flex: 1 }} onLayout={handleLayout}>\r\n              <Animated.View\r\n                style={{\r\n                  flex: 1,\r\n                  [targetDimension]: totalDimension,\r\n                  transform: [{ [targetTransform]: containerTranslation }],\r\n                }}\r\n              >\r\n                {renderChildren()}\r\n              </Animated.View>\r\n            </Animated.View>\r\n          </Animated.View>\r\n        </Animated.View>\r\n      </PanGestureHandler>\r\n    </Animated.View>\r\n  );\r\n}\r\n\r\ninterface iPage {\r\n  children: React.ReactNode;\r\n  index: number;\r\n  minimum: Animated.Node<number>;\r\n  maximum: Animated.Node<number>;\r\n  dimension: Animated.Node<number>;\r\n  targetTransform: 'translateX' | 'translateY';\r\n  targetDimension: 'width' | 'height';\r\n  pageInterpolation: iPageInterpolation | undefined;\r\n  animatedIndex: Animated.Value<number>;\r\n}\r\n\r\nfunction Page({\r\n  children,\r\n  index,\r\n  minimum,\r\n  maximum,\r\n  dimension,\r\n  targetTransform,\r\n  targetDimension,\r\n  pageInterpolation,\r\n  animatedIndex,\r\n}: iPage) {\r\n  // compute the absolute position of the page based on index and dimension\r\n  // this means that it's not relative to any other child, which is good because\r\n  // it doesn't rely on a mechanism like flex, which requires all children to be present\r\n  // to properly position pages\r\n  const position = memoize(multiply(index, dimension));\r\n\r\n  // min-max the position based on clamp values\r\n  // this means the <Page /> will have a container that is always positioned\r\n  // in the same place, but the inner view can be translated within these bounds\r\n  const translation = memoize(min(max(position, minimum), maximum));\r\n\r\n  const defaultStyle = memoize({\r\n    // map to height / width value depending on vertical / horizontal configuration\r\n    // this is crucial to getting child views to properly lay out\r\n    [targetDimension]: dimension,\r\n    // min-max the position based on clamp values\r\n    // this means the <Page /> will have a container that is always positioned\r\n    // in the same place, but the inner view can be translated within these bounds\r\n    transform: [\r\n      {\r\n        [targetTransform]: translation,\r\n      },\r\n    ],\r\n  });\r\n\r\n  // compute the relative offset value to the current animated index so\r\n  // that <Page /> can use interpolation values that are in sync with drag gestures\r\n  const offset = memoize(sub(index, animatedIndex));\r\n\r\n  // apply interpolation configs to <Page />\r\n  const interpolatedStyles = memoize(\r\n    interpolateWithConfig(offset, pageInterpolation)\r\n  );\r\n\r\n  // take out zIndex here as it needs to be applied to siblings\r\n  let { zIndex, ...otherStyles } = interpolatedStyles;\r\n\r\n  // zIndex is not a requirement of interpolation\r\n  // it will be clear when someone needs it as views will overlap with some configurations\r\n  if (!zIndex) {\r\n    zIndex = 0;\r\n  }\r\n\r\n  return (\r\n    <Animated.View\r\n      style={{\r\n        ...StyleSheet.absoluteFillObject,\r\n        ...defaultStyle,\r\n        zIndex,\r\n      }}\r\n    >\r\n      <Animated.View style={[StyleSheet.absoluteFillObject, otherStyles]}>\r\n        {children}\r\n      </Animated.View>\r\n    </Animated.View>\r\n  );\r\n}\r\n\r\n// utility to update animated values without changing their reference\r\n// this is key for using memoized Animated.Values and prevents costly rerenders\r\nfunction useAnimatedValue(\r\n  value?: number,\r\n  defaultValue = 0\r\n): Animated.Value<number> {\r\n  const initialValue = value !== undefined ? value : defaultValue;\r\n  const animatedValue = memoize(new Value(initialValue));\r\n\r\n  useEffect(() => {\r\n    if (value !== undefined) {\r\n      animatedValue.setValue(value);\r\n    }\r\n  }, [value]);\r\n\r\n  return animatedValue;\r\n}\r\n\r\ntype iPagerContext = [\r\n  number,\r\n  (nextIndex: number) => void,\r\n  Animated.Value<number>\r\n];\r\n\r\nconst PagerContext = createContext<undefined | iPagerContext>(undefined);\r\n\r\ninterface iPagerProvider {\r\n  children: React.ReactNode;\r\n  initialIndex?: number;\r\n  activeIndex?: number;\r\n  onChange?: (nextIndex: number) => void;\r\n}\r\n\r\nfunction PagerProvider({\r\n  children,\r\n  initialIndex = 0,\r\n  activeIndex: parentActiveIndex,\r\n  onChange: parentOnChange = () =>\r\n    console.warn(\r\n      '<PagerProvider /> should have an onChange() prop if it is controlled'\r\n    ),\r\n}: iPagerProvider) {\r\n  const [_activeIndex, _setActiveIndex] = useState(initialIndex);\r\n\r\n  const isControlled = parentActiveIndex !== undefined;\r\n\r\n  const activeIndex = isControlled ? parentActiveIndex : _activeIndex;\r\n  const onChange = isControlled ? parentOnChange : _setActiveIndex;\r\n\r\n  const animatedIndex = memoize(new Value(activeIndex));\r\n\r\n  return (\r\n    <PagerContext.Provider\r\n      value={[activeIndex, onChange, animatedIndex] as iPagerContext}\r\n    >\r\n      {typeof children === 'function'\r\n        ? children({ activeIndex, onChange, animatedIndex })\r\n        : children}\r\n    </PagerContext.Provider>\r\n  );\r\n}\r\n\r\nfunction usePager(): iPagerContext {\r\n  const context = useContext(PagerContext);\r\n\r\n  if (context === undefined) {\r\n    throw new Error(`usePager() must be used within a <PagerProvider />`);\r\n  }\r\n\r\n  return context;\r\n}\r\n\r\n// provide hook for child screens to access pager focus:\r\nconst FocusContext = React.createContext(false);\r\n\r\ninterface iFocusProvider {\r\n  children: React.ReactNode;\r\n  focused: boolean;\r\n}\r\n\r\nfunction FocusProvider({ focused, children }: iFocusProvider) {\r\n  return (\r\n    <FocusContext.Provider value={focused}>{children}</FocusContext.Provider>\r\n  );\r\n}\r\n\r\nfunction useFocus() {\r\n  const focused = useContext(FocusContext);\r\n\r\n  return focused;\r\n}\r\n\r\nconst IndexContext = React.createContext<undefined | number>(undefined);\r\n\r\ninterface iIndexProvider {\r\n  children: React.ReactNode;\r\n  index: number;\r\n}\r\n\r\nfunction IndexProvider({ children, index }: iIndexProvider) {\r\n  return (\r\n    <IndexContext.Provider value={index}>{children}</IndexContext.Provider>\r\n  );\r\n}\r\n\r\nfunction useIndex() {\r\n  const index = useContext(IndexContext);\r\n\r\n  if (index === undefined) {\r\n    throw new Error(`useIndex() must be used within an <IndexProvider />`);\r\n  }\r\n\r\n  return index;\r\n}\r\n\r\nfunction useOnFocus(fn: Function) {\r\n  const focused = useFocus();\r\n\r\n  useEffect(() => {\r\n    if (focused) {\r\n      fn();\r\n    }\r\n  }, [focused]);\r\n}\r\n\r\nfunction useAnimatedIndex() {\r\n  const pager = usePager();\r\n  return pager[2];\r\n}\r\n\r\nfunction useOffset(index: number) {\r\n  const animatedIndex = useAnimatedIndex();\r\n  const offset = memoize(sub(index, animatedIndex));\r\n\r\n  return offset;\r\n}\r\n\r\nfunction useInterpolation(\r\n  pageInterpolation: iPageInterpolation,\r\n  index?: number\r\n) {\r\n  const _index = index !== undefined ? index : useIndex();\r\n  const offset = useOffset(_index);\r\n  const styles = memoize(interpolateWithConfig(offset, pageInterpolation));\r\n  return styles;\r\n}\r\n\r\nfunction interpolateWithConfig(\r\n  offset: Animated.Node<number>,\r\n  pageInterpolation?: iPageInterpolation\r\n): ViewStyle {\r\n  if (!pageInterpolation) {\r\n    return {};\r\n  }\r\n\r\n  return Object.keys(pageInterpolation).reduce((styles: any, key: any) => {\r\n    const currentStyle = pageInterpolation[key];\r\n\r\n    if (Array.isArray(currentStyle)) {\r\n      const _style = currentStyle.map((interpolationConfig: any) =>\r\n        interpolateWithConfig(offset, interpolationConfig)\r\n      );\r\n\r\n      styles[key] = _style;\r\n      return styles;\r\n    }\r\n\r\n    if (typeof currentStyle === 'object') {\r\n      let _style;\r\n      const { unit, ...rest } = currentStyle;\r\n      if (currentStyle.unit) {\r\n        _style = concat(interpolate(offset, rest), currentStyle.unit);\r\n      } else {\r\n        _style = interpolate(offset, currentStyle);\r\n      }\r\n\r\n      styles[key] = _style;\r\n      return styles;\r\n    }\r\n\r\n    if (typeof currentStyle === 'function') {\r\n      const _style = currentStyle(offset);\r\n      styles[key] = _style;\r\n      return styles;\r\n    }\r\n\r\n    return styles;\r\n  }, {});\r\n}\r\n\r\nfunction memoize(value: any): any {\r\n  const ref = React.useRef(value);\r\n  return ref.current;\r\n}\r\n\r\nconst DEFAULT_SPRING_CONFIG = {\r\n  stiffness: 1000,\r\n  damping: 500,\r\n  mass: 3,\r\n  overshootClamping: false,\r\n  restDisplacementThreshold: 0.01,\r\n  restSpeedThreshold: 0.01,\r\n};\r\n\r\nfunction runSpring(\r\n  clock: Animated.Clock,\r\n  position: Animated.Value<number>,\r\n  toValue: Animated.Node<number>,\r\n  springConfig?: Partial<SpringConfig>\r\n) {\r\n  const state = {\r\n    finished: new Value(0),\r\n    velocity: new Value(0),\r\n    position: position,\r\n    time: new Value(0),\r\n  };\r\n\r\n  const config = {\r\n    ...DEFAULT_SPRING_CONFIG,\r\n    ...springConfig,\r\n    toValue: new Value(0),\r\n  };\r\n\r\n  return block([\r\n    cond(\r\n      clockRunning(clock),\r\n      [\r\n        cond(neq(config.toValue, toValue), [\r\n          set(state.finished, 0),\r\n          set(config.toValue, toValue),\r\n        ]),\r\n      ],\r\n      [\r\n        set(state.finished, 0),\r\n        set(state.time, 0),\r\n        set(state.velocity, 0),\r\n        set(config.toValue, toValue),\r\n        startClock(clock),\r\n      ]\r\n    ),\r\n    spring(clock, state, config),\r\n    cond(state.finished, [stopClock(clock), set(state.position, position)]),\r\n    state.position,\r\n  ]);\r\n}\r\n\r\nexport {\r\n  Pager,\r\n  PagerProvider,\r\n  PagerContext,\r\n  usePager,\r\n  useFocus,\r\n  useOffset,\r\n  useOnFocus,\r\n  useIndex,\r\n  useAnimatedIndex,\r\n  useInterpolation,\r\n  IndexProvider,\r\n  FocusProvider,\r\n};\r\n","import { useRef } from 'react';\r\nimport { ViewStyle } from 'react-native';\r\nimport Animated from 'react-native-reanimated';\r\nimport { iPageInterpolation, SpringConfig } from './pager';\r\n\r\nconst {\r\n  interpolate,\r\n  concat,\r\n  Value,\r\n  clockRunning,\r\n  cond,\r\n  neq,\r\n  set,\r\n  startClock,\r\n  spring,\r\n  stopClock,\r\n  block,\r\n} = Animated;\r\n\r\nfunction interpolateWithConfig(\r\n  offset: Animated.Node<number>,\r\n  pageInterpolation?: iPageInterpolation\r\n): ViewStyle {\r\n  if (!pageInterpolation) {\r\n    return {};\r\n  }\r\n\r\n  return Object.keys(pageInterpolation).reduce((styles: any, key: any) => {\r\n    const currentStyle = pageInterpolation[key];\r\n\r\n    if (Array.isArray(currentStyle)) {\r\n      const _style = currentStyle.map((interpolationConfig: any) =>\r\n        interpolateWithConfig(offset, interpolationConfig)\r\n      );\r\n\r\n      styles[key] = _style;\r\n      return styles;\r\n    }\r\n\r\n    if (typeof currentStyle === 'object') {\r\n      let _style;\r\n      const { unit, ...rest } = currentStyle;\r\n      if (currentStyle.unit) {\r\n        _style = concat(interpolate(offset, rest), currentStyle.unit);\r\n      } else {\r\n        _style = interpolate(offset, currentStyle);\r\n      }\r\n\r\n      styles[key] = _style;\r\n      return styles;\r\n    }\r\n\r\n    if (typeof currentStyle === 'function') {\r\n      const _style = currentStyle(offset);\r\n      styles[key] = _style;\r\n      return styles;\r\n    }\r\n\r\n    return styles;\r\n  }, {});\r\n}\r\n\r\nfunction memoize(value: any): any {\r\n  const ref = useRef(value);\r\n  return ref.current;\r\n}\r\n\r\nconst DEFAULT_SPRING_CONFIG = {\r\n  stiffness: 1000,\r\n  damping: 500,\r\n  mass: 3,\r\n  overshootClamping: false,\r\n  restDisplacementThreshold: 0.01,\r\n  restSpeedThreshold: 0.01,\r\n};\r\n\r\nfunction runSpring(\r\n  clock: Animated.Clock,\r\n  position: Animated.Value<number>,\r\n  toValue: Animated.Node<number>,\r\n  springConfig?: Partial<SpringConfig>\r\n) {\r\n  const state = {\r\n    finished: new Value(0),\r\n    velocity: new Value(0),\r\n    position: position,\r\n    time: new Value(0),\r\n  };\r\n\r\n  const config = {\r\n    ...DEFAULT_SPRING_CONFIG,\r\n    ...springConfig,\r\n    toValue: new Value(0),\r\n  };\r\n\r\n  return block([\r\n    cond(\r\n      clockRunning(clock),\r\n      [\r\n        cond(neq(config.toValue, toValue), [\r\n          set(state.finished, 0),\r\n          set(config.toValue, toValue),\r\n        ]),\r\n      ],\r\n      [\r\n        set(state.finished, 0),\r\n        set(state.time, 0),\r\n        set(state.velocity, 0),\r\n        set(config.toValue, toValue),\r\n        startClock(clock),\r\n      ]\r\n    ),\r\n    spring(clock, state, config),\r\n    cond(state.finished, [stopClock(clock), set(state.position, position)]),\r\n    state.position,\r\n  ]);\r\n}\r\n\r\nexport { interpolateWithConfig, memoize, runSpring };\r\n","import React, { Children } from 'react';\r\nimport Animated from 'react-native-reanimated';\r\nimport { ViewStyle, LayoutChangeEvent } from 'react-native';\r\nimport { iPageInterpolation, useOffset, useAnimatedIndex } from './pager';\r\nimport { memoize, interpolateWithConfig } from './util';\r\n\r\nconst { Value, divide, multiply, add } = Animated;\r\n\r\ninterface iPagination {\r\n  children: React.ReactNode;\r\n  pageInterpolation: iPageInterpolation;\r\n  style?: ViewStyle;\r\n}\r\n\r\nconst DEFAULT_PAGINATION_STYLE: ViewStyle = {\r\n  height: 50,\r\n  width: '100%',\r\n  flexDirection: 'row',\r\n};\r\n\r\nfunction Pagination({ children, pageInterpolation, style }: iPagination) {\r\n  return (\r\n    <Animated.View\r\n      style={{\r\n        ...DEFAULT_PAGINATION_STYLE,\r\n        ...style,\r\n      }}\r\n    >\r\n      {Children.map(children, (child: any, index) => (\r\n        <PaginationItem\r\n          index={index}\r\n          pageInterpolation={pageInterpolation}\r\n          style={child.props.style}\r\n        >\r\n          {child}\r\n        </PaginationItem>\r\n      ))}\r\n    </Animated.View>\r\n  );\r\n}\r\n\r\ninterface iPaginationItem {\r\n  children: React.ReactNode;\r\n  pageInterpolation: iPageInterpolation;\r\n  index: number;\r\n  style?: ViewStyle;\r\n}\r\n\r\nfunction PaginationItem({\r\n  children,\r\n  pageInterpolation,\r\n  index,\r\n  style,\r\n}: iPaginationItem) {\r\n  const offset = useOffset(index);\r\n  const configStyles = memoize(\r\n    interpolateWithConfig(offset, pageInterpolation)\r\n  );\r\n\r\n  return (\r\n    <Animated.View style={[style || { flex: 1 }, configStyles]}>\r\n      {children}\r\n    </Animated.View>\r\n  );\r\n}\r\n\r\ninterface iSlider {\r\n  numberOfScreens: number;\r\n  style: ViewStyle;\r\n}\r\n\r\nconst DEFAULT_SLIDER_STYLE = {\r\n  height: 2,\r\n  backgroundColor: 'aquamarine',\r\n};\r\n\r\nfunction Slider({ numberOfScreens, style }: iSlider) {\r\n  const animatedIndex = useAnimatedIndex();\r\n  const width = memoize(new Value(0));\r\n\r\n  function handleLayout({ nativeEvent: { layout } }: LayoutChangeEvent) {\r\n    width.setValue(layout.width as any);\r\n  }\r\n\r\n  const sliderWidth = divide(width, numberOfScreens);\r\n  const translation = memoize(multiply(animatedIndex, sliderWidth));\r\n\r\n  return (\r\n    <Animated.View onLayout={handleLayout}>\r\n      <Animated.View\r\n        style={{\r\n          width: sliderWidth,\r\n          transform: [{ translateX: translation }],\r\n          ...DEFAULT_SLIDER_STYLE,\r\n          ...style,\r\n        }}\r\n      />\r\n    </Animated.View>\r\n  );\r\n}\r\n\r\nfunction Progress({ numberOfScreens, style }: iSlider) {\r\n  const animatedIndex = useAnimatedIndex();\r\n\r\n  const width = memoize(new Value(0));\r\n\r\n  function handleLayout({ nativeEvent: { layout } }: LayoutChangeEvent) {\r\n    width.setValue(layout.width as any);\r\n  }\r\n\r\n  const sliderWidth = memoize(\r\n    divide(width, numberOfScreens, divide(1, add(animatedIndex, 1)))\r\n  );\r\n\r\n  return (\r\n    <Animated.View onLayout={handleLayout}>\r\n      <Animated.View\r\n        style={{\r\n          width: sliderWidth,\r\n          height: 2,\r\n          backgroundColor: 'rebeccapurple',\r\n          ...DEFAULT_SLIDER_STYLE,\r\n          ...style,\r\n        }}\r\n      />\r\n    </Animated.View>\r\n  );\r\n}\r\n\r\nexport { Pagination, Slider, Progress };\r\n"],"names":["Extrapolate","event","Animated","block","Value","divide","cond","eq","add","stopClock","Clock","set","clockRunning","multiply","sub","call","max","min","greaterThan","abs","ceil","interpolate","concat","neq","and","startClock","spring","Page","children","index","minimum","maximum","dimension","targetTransform","targetDimension","pageInterpolation","animatedIndex","position","memoize","translation","defaultStyle","transform","offset","interpolatedStyles","interpolateWithConfig","zIndex","otherStyles","React","View","style","StyleSheet","absoluteFillObject","useAnimatedValue","value","defaultValue","animatedValue","undefined","useEffect","setValue","PagerContext","createContext","usePager","context","useContext","Error","FocusContext","FocusProvider","Provider","focused","useFocus","IndexContext","IndexProvider","useIndex","useAnimatedIndex","useOffset","Object","keys","reduce","styles","key","currentStyle","Array","isArray","_style","map","interpolationConfig","rest","unit","useRef","current","DEFAULT_SPRING_CONFIG","stiffness","damping","mass","overshootClamping","restDisplacementThreshold","restSpeedThreshold","runSpring","clock","toValue","springConfig","state","finished","velocity","time","config","DEFAULT_PAGINATION_STYLE","height","width","flexDirection","PaginationItem","configStyles","flex","DEFAULT_SLIDER_STYLE","backgroundColor","parentActiveIndex","activeIndex","parentOnChange","onChange","initialIndex","panProps","pageSize","threshold","minIndex","parentMax","maxIndex","adjacentChildOffset","containerStyle","type","clamp","clampDrag","isControlled","useState","_onChange","numberOfScreens","Children","count","Math","dragX","dragY","gestureState","handleGesture","nativeEvent","translationX","translationY","useNativeDriver","handleStateChange","initialWidth","initialHeight","setWidth","setHeight","delta","layoutDimension","totalDimension","TYPE","animatedThreshold","clampDragPrev","prev","clampDragNext","next","animatedMaxIndex","animatedMinIndex","_position","dragStart","swiping","nextIndex","animatedActiveIndex","change","absChange","shouldTransition","indexChange","clampedDelta","State","ACTIVE","clampPrevValue","clampNextValue","animatedPageSize","containerTranslation","adjacentChildren","slice","Code","exec","PanGestureHandler","onGestureEvent","onHandlerStateChange","onLayout","layout","child","i","console","warn","props","sliderWidth","translateX","fn"],"mappings":"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"}